#undef SHARED_MEMORY
SUBROUTINE BGSDE_OBS

  USE SET_KND
  USE GRD_STR
  USE EOF_STR
  USE OBS_STR
  USE MYFRTPROF
  USE IOUNITS
  USE RUN, ONLY : IANMM, IANDD
  USE OBSHANDLING
  USE MPIREL, ONLY : CMPIDOM, MYPROC
  USE MYNETCDF

  IMPLICIT NONE

  INTEGER (I4)               :: I, J, K, JOBS
  INTEGER (I4)               :: KI, JVL
  INTEGER (I4)               :: D, KP, I2, KBOT
  INTEGER (I4)               :: XIND1, JEOF
  INTEGER (I4)               :: KT2, KQ2
  REAL(R8)       :: BGTOT(GRD%IM,GRD%JM,GRD%KM,2)
  REAL(R8)       :: BGT(GRD%IM,GRD%JM,GRD%KM)
  REAL(R8)       :: BGT2M(GRD%IM,GRD%JM)
  REAL(R8)       :: BGQ2M(GRD%IM,GRD%JM)
  REAL(R8)       :: BGS(GRD%IM,GRD%JM,GRD%KM)
  REAL(R8)       :: BGT2 (GRD%IM,GRD%JM)
  REAL(R8) ::  A2,A2_TL,B2,B2_TL,C2,ROOTS,RHOW_TL, T, S, ZRHO
  REAL(R8) ::  BGERR, RHTL, TB, SB
  REAL(R8), PARAMETER :: RHO0 = 1028._R8
  REAL(R8) ::  SLAEOF(ROS%NREG,ROS%NEOF)

  CALL MYFRTPROF_WALL('BGSDE_OBS: FORM BG STDEV ERRORS FOR OBS',0)

  WRITE(IOUNLOG,*) 
  WRITE(IOUNLOG,*) ' FORMING BG ERRORS IN OBS SPACE'
  WRITE(IOUNLOG,*) ' LL_READ_BGE OPTION : ',LL_READ_BGE

  IF( LL_READ_BGE ) THEN
        CALL READ_BGERRS('bgerrors.nc',GRD%IM,GRD%JM,GRD%KM,&
                         BGTOT(:,:,:,2),BGTOT(:,:,:,1),BGT2)
  ELSE

#ifdef SHARED_MEMORY
!$OMP PARALLEL DEFAULT(SHARED), PRIVATE(K,J,I,KI)
!$OMP DO SCHEDULE(DYNAMIC,1)
#endif
    DO K=1,GRD%KM
     DO J=1,GRD%JM
      DO I=1,GRD%IM
        KI=GRD%REG(I,J)
        ! SALINITY
        BGTOT(I,J,K,1) = SQRT( SUM( ROS%EVC(KI,K+GRD%KM,:) * &
        & ROS%EVA(KI,:) * ROS%EVA(KI,:) * ROS%EVC(KI,K+GRD%KM,:) ) )
        ! TEMPERATURE
        BGTOT(I,J,K,2) = SQRT( SUM( ROS%EVC(KI,K,:) * &
        & ROS%EVA(KI,:) * ROS%EVA(KI,:) * ROS%EVC(KI,K,:) ) )
      ENDDO
     ENDDO
    ENDDO
#ifdef SHARED_MEMORY
!$OMP END DO
!$OMP END PARALLEL
#endif

   IF(LL_TQ2_ASSIM .AND. LL_TQ2) THEN
     KT2=2*GRD%KM+COUNT( (/LL_SSH/) ) +1
     KQ2=KT2+1
     DO J=1,GRD%JM
      DO I=1,GRD%IM
        KI=GRD%REG(I,J)
        ! T2M
        BGT2M(I,J) = SQRT( SUM( ROS%EVC(KI,KT2,:) * &
        & ROS%EVA(KI,:) * ROS%EVA(KI,:) * ROS%EVC(KI,KT2,:) ) )
        ! Q2M
        BGQ2M(I,J) = SQRT( SUM( ROS%EVC(KI,KQ2,:) * &
        & ROS%EVA(KI,:) * ROS%EVA(KI,:) * ROS%EVC(KI,KQ2,:) ) )
      ENDDO
     ENDDO
   ENDIF

    IF( NPRINTEOF .GT. 5 ) THEN
      CALL WRITE_VARNCDF('SALBG_STDEV_'//TRIM(CMPIDOM)//'.NC',&
      & GRD%IM,GRD%JM,GRD%KM,BGTOT(:,:,:,1),'bgsd',&
      & ' ','background-error st.dev.')
      CALL WRITE_VARNCDF('TEMBG_STDEV_'//TRIM(CMPIDOM)//'.NC',&
      & GRD%IM,GRD%JM,GRD%KM,BGTOT(:,:,:,2),'bgsd',&
      & ' ','background-error st.dev.')
    ENDIF

    IF( SLA%NO .GT. 0 ) THEN

     ! READ CLIM
     CALL READ_CLIM(IANMM*100+IANDD,GRD%IM,GRD%JM,GRD%KM,BGT,BGS)

#ifdef SHARED_MEMORY
!$OMP PARALLEL DEFAULT(SHARED), PRIVATE(J,I,JEOF,KI,KBOT,RHTL,&
!$OMP & JVL,TB,SB,T,S,A2,A2_TL,B2,B2_TL,C2,ROOTS,RHOW_TL,ZRHO)
!$OMP DO SCHEDULE(DYNAMIC,1)
#endif
     DO J=1,GRD%JM
      DO I=1,GRD%IM
       DO JEOF=1,ROS%NEOF
         KI=GRD%REG(I,J)
         KBOT=GRD%KM
         RHTL = 0._R8
         VLEV : DO JVL = KBOT,1,-1
           IF(GRD%MSK(I,J,JVL) .LT. 0.9_R8 ) CYCLE VLEV
           TB      = BGT(I,J,JVL)
           SB      = MAX(1.0_R8,BGS(I,J,JVL))
           T       = ROS%EVC(KI,JVL,JEOF)
           S       = ROS%EVC(KI,JVL+GRD%KM,JEOF)
#include "rho_unescotl_r8.h"
           RHTL = RHTL + ZRHO*GRD%DZ(JVL)
         ENDDO VLEV
         SLAEOF(KI,JEOF) = -1._R8*RHTL/RHO0
       ENDDO
       BGT2( I, J ) = SQRT( SUM( SLAEOF(KI,:) * &
       & ROS%EVA(KI,:) * ROS%EVA(KI,:) * SLAEOF(KI,:) ) )
     ENDDO
    ENDDO
#ifdef SHARED_MEMORY
!$OMP END DO
!$OMP END PARALLEL
#endif
   ENDIF

  ENDIF

IF( INS%NO .GT. 0 ) THEN

#ifdef SHARED_MEMORY
!$OMP PARALLEL DEFAULT(SHARED), PRIVATE(JOBS,D,KP)
!$OMP DO SCHEDULE(DYNAMIC,1)
#endif
LOOPINS : DO JOBS=1,INS%NO

     IF(INS%FLC(JOBS) .NE. 1 ) CYCLE LOOPINS
     
     D=INS%KB(JOBS)
     KP=INS%PAR(JOBS)

     IF(LL_TQ2_ASSIM.AND.(INS%PAR(JOBS).EQ.KKT2M.OR.INS%PAR(JOBS).EQ.KKQ2M)) THEN
      IF(INS%PAR(JOBS).EQ.KKT2M) THEN
       INS%BGERR(JOBS) = OSUM(INS%PQ(JOBS,1:NPQ),BGT2M(INS%IB(JOBS,1:NPQ),INS%JB(JOBS,1:NPQ)))
      ELSE
       INS%BGERR(JOBS) = OSUM(INS%PQ(JOBS,1:NPQ),BGQ2M(INS%IB(JOBS,1:NPQ),INS%JB(JOBS,1:NPQ)))
      ENDIF
     ELSE
      INS%BGERR(JOBS) = &
      & OSUM( INS%PQ(JOBS,1:NPQ),BGTOT(INS%IB(JOBS,1:NPQ),INS%JB(JOBS,1:NPQ),D  ,KP) )+ &
      & OSUM( INS%PQ(JOBS,NPQ+1:2*NPQ),BGTOT(INS%IB(JOBS,1:NPQ),INS%JB(JOBS,1:NPQ),D+1,KP) )
     ENDIF
     IF( NPRINTEOF .GT. 5 ) THEN
       WRITE(1301+MYPROC,'(2I4,8I4,8F8.4,9F8.4)') D, KP,&
       INS%IB(JOBS,1:NPQ),INS%JB(JOBS,1:NPQ), &
       INS%PQ(JOBS,1:(2*NPQ)),&
       BGTOT(INS%IB(JOBS,1),INS%JB(JOBS,1),D,KP),&
       BGTOT(INS%IB(JOBS,2),INS%JB(JOBS,2),D,KP),&
       BGTOT(INS%IB(JOBS,3),INS%JB(JOBS,3),D,KP),&
       BGTOT(INS%IB(JOBS,4),INS%JB(JOBS,4),D,KP),&
       BGTOT(INS%IB(JOBS,1),INS%JB(JOBS,1),D+1,KP),&
       BGTOT(INS%IB(JOBS,2),INS%JB(JOBS,2),D+1,KP),&
       BGTOT(INS%IB(JOBS,3),INS%JB(JOBS,3),D+1,KP),&
       BGTOT(INS%IB(JOBS,4),INS%JB(JOBS,4),D+1,KP),&
       INS%BGERR(JOBS)
     ENDIF

ENDDO LOOPINS
#ifdef SHARED_MEMORY
!$OMP END DO
!$OMP END PARALLEL
#endif

ENDIF

IF( SST%NO .GT. 0 ) THEN
LOOPSST : DO JOBS=1,SST%NO

     IF(SST%FLC(JOBS) .NE. 1 ) CYCLE LOOPSST

     D=1
     KP=2
        
     SST%BGERR(JOBS) = &
     & OSUM( SST%PQ(JOBS,1:NPQ),BGTOT(SST%IB(JOBS,1:NPQ),SST%JB(JOBS,1:NPQ),D,KP) )


ENDDO LOOPSST
ENDIF

IF( SSS%NO .GT. 0 ) THEN
LOOPSSS : DO JOBS=1,SSS%NO

     IF(SSS%FLC(JOBS) .NE. 1 ) CYCLE LOOPSSS

     D=1
     KP=1

     SSS%BGERR(JOBS) = &
     & OSUM( SSS%PQ(JOBS,1:NPQ),BGTOT(SSS%IB(JOBS,1:NPQ),SSS%JB(JOBS,1:NPQ),D,KP) )

ENDDO LOOPSSS
ENDIF


IF( SLA%NO .GT. 0 ) THEN
LOOPSLA : DO JOBS=1,SLA%NO

     IF(SLA%FLC(JOBS) .NE. 1 ) CYCLE LOOPSLA

     SLA%BGERR(JOBS) = &
     & OSUM( SLA%PQ(JOBS,1:NPQ),BGT2(SLA%IB(JOBS,1:NPQ),SLA%JB(JOBS,1:NPQ) ) )

ENDDO LOOPSLA
ENDIF

CALL MYFRTPROF_WALL('BGSDE_OBS: FORM BG STDEV ERRORS FOR OBS',1)

END SUBROUTINE BGSDE_OBS

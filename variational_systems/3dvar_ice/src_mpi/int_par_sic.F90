#undef SHARED_MEMORY
SUBROUTINE INT_PAR_SIC

!-----------------------------------------------------------------------
!                                                                      !
! GET INTERPOLATION PARAMETERS FOR A GRID                              !
!                                                                      !
!-----------------------------------------------------------------------

 USE SET_KND
 USE GRD_STR
! USE PHINTERP
 USE PHINTERP2
 USE RUN
 USE OBS_STR
 USE MYFRTPROF, ONLY : MYFRTPROF_WALL
 USE IOUNITS

 IMPLICIT NONE

  INTEGER(I4)   ::  K, N_TOPEX, N_ERS, II, JJ,I2
  INTEGER(I4)   ::  I1, J1, KK, I, J, ITER, IAUX, JP
  INTEGER(I4)   ::  MSCOUNT
  REAL(R8)      ::  P1, Q1, P, Q, SUMT, SUMI, NEWLON
  REAL(R8)      ::  MSK4, ZZSS,ZVAL_SIC

#include "obs_events.h"

 CALL MYFRTPROF_WALL('INT_PAR_SIC: SIC INTERPOLATION',0)

 IF(SIC%NO.EQ.0) THEN
   CALL MYFRTPROF_WALL('INT_PAR_SIC: SIC INTERPOLATION',1)
   RETURN
 ENDIF

 SIC%FLC = 0
 SIC%IB  = 0
 SIC%JB  = 0
 SIC%TDIST(1:SIC%NO)=SIC%TIM(1:SIC%NO) - ZANJUL1950


#ifdef SHARED_MEMORY
!$OMP PARALLEL DEFAULT(PRIVATE), SHARED(SIC)
!$OMP DO SCHEDULE(DYNAMIC)
#endif
CYOBS0 : DO KK = 1,SIC%NO

      IF( SIC%EVE(KK) .EQ. KEVE_PDOM ) CYCLE CYOBS0

         CALL PREPINTERP2(SIC%LON(KK),SIC%LAT(KK),SIC%IB(KK,:),SIC%JB(KK,:),SIC%PQ(KK,:))

ENDDO CYOBS0
#ifdef SHARED_MEMORY
!$OMP END DO
!$OMP END PARALLEL
#endif

#ifdef SHARED_MEMORY
!$OMP PARALLEL DEFAULT(SHARED), PRIVATE(KK,ZZSS,JP,MSK4)
!$OMP DO SCHEDULE(DYNAMIC)
#endif
CYOBS : DO KK = 1,SIC%NO
       IF( ALL(SIC%IB(KK,:).GT.1 ) .AND. ALL(SIC%JB(KK,:).GT.1 ) .AND. &
       & ALL(SIC%IB(KK,:).LT.GRD%IM ) .AND. ALL(SIC%JB(KK,:).LT.GRD%JM ) ) THEN
          SIC%FLC(KK) = 1
       ELSE
          SIC%FLC(KK) = 0
          SIC%EVE(KK) = KEVE_INTE
          CYCLE CYOBS
       ENDIF

       SIC%PQ(KK,1) = SIC%PQ(KK,1) * GRD%MSK(SIC%IB(KK,1),SIC%JB(KK,1),1)
       SIC%PQ(KK,2) = SIC%PQ(KK,2) * GRD%MSK(SIC%IB(KK,2),SIC%JB(KK,2),1)
       SIC%PQ(KK,3) = SIC%PQ(KK,3) * GRD%MSK(SIC%IB(KK,3),SIC%JB(KK,3),1)
       SIC%PQ(KK,4) = SIC%PQ(KK,4) * GRD%MSK(SIC%IB(KK,4),SIC%JB(KK,4),1)
       
       ZZSS = 0._R8
       ZVAL_SIC = 0._R8
       DO JP=1,NPQ
         ZZSS = ZZSS + GRD%MSK(SIC%IB(KK,JP),SIC%JB(KK,JP),1)
         ZVAL_SIC = ZVAL_SIC +GRD%SICB(SIC%IB(KK,JP),SIC%JB(KK,JP),1) 
      ENDDO

       IF( ABS( ZZSS ) .LT. 1._R8 .OR. abs(ZVAL_SIC) .GT. 99999._R8) THEN
           SIC%FLC(KK) = 0
           SIC%EVE(KK) = KEVE_MASK
           CYCLE CYOBS
       ELSE
           SIC%PQ(KK,:) = SIC%PQ(KK,:) / SUM(SIC%PQ(KK,:))
       ENDIF

ENDDO CYOBS
#ifdef SHARED_MEMORY
!$OMP END DO
!$OMP END PARALLEL
#endif

MSCOUNT=COUNT(SIC%EVE(1:SIC%NO).EQ.KEVE_INTE)
WRITE(IOUNLOG,*) &
& ' SIC OBS FILTERED OUT FOR INTERP PROBLEMS: ',MSCOUNT

MSCOUNT=COUNT(SIC%EVE(1:SIC%NO).EQ.KEVE_MASK)
WRITE(IOUNLOG,*) &
& ' SIC OBS FILTERED OUT FOR MASKING INCONSISTENCIES: ',MSCOUNT

! ---
! COUNT GOOD OBSERVATIONS
  SIC%NC = COUNT(SIC%FLC(1:SIC%NO) .EQ. 1)

  WRITE(IOUNLOG,*)
  WRITE(IOUNLOG,*) ' *** SIC OBS AFTER INTERPOLATION SET-UP'
  WRITE(IOUNLOG,*) ' TOTAL NUMBER OF SIC OBS           :',SIC%NO
  WRITE(IOUNLOG,*) ' TOTAL NUMBER OF RETAINED SIC  OBS :',SIC%NC

CALL MYFRTPROF_WALL('INT_PAR_SIC: SIC INTERPOLATION',1)
END SUBROUTINE INT_PAR_SIC
